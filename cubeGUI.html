<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rubiks Cube - Mapping Model</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            display: block;
            background-color: #EEE;
        }
    </style>
</head>

<body>
    <button type="button" onclick = ""></button>
    <script>
    

        //Three.js object setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        camera.position.set(4, 4, 4);
        camera.lookAt(scene.position);


        const group = new THREE.Group(); //Collection of entire cubie container
        const groups = {
            front: new Array(), right: new Array(), //ordered cubie lists per face, used to parse .json from server response
            back: new Array(), left: new Array(), up: new Array(), down: new Array()
        };
        let map = {};
            map[0] = 0;
            map[1] = 4;
            map[2] = 5;
            map[3] = 1;
            map[4] = 2;
            map[5] = 3;
            
        const pointer = { x: 0, y: 0, horizontal: false };  //Horizontal Indicates z-directional control amongst cubies
        scene.add(group);
        animate();

        //Orientation specific loop for assigning face colors from server response
       // Delayed Addition Function
function addCubesWithDelay() {
    const CUBE_DIMENSION = 3;
    let x = 0, y = 0, z = 0;

    function addNextCube() {
        if (x < CUBE_DIMENSION) {
            if (y < CUBE_DIMENSION) {
                if (z < CUBE_DIMENSION) {
                    const cube = createCube(x, y, z);
                    cube.userData = { coordinates: { x, y, z } };
                    cube.position.set(x - 1, y - 1, z - 1);
                    // Organization logic if needed
                    z++;
                } else {
                    z = 0;
                    y++;
                }
            } else {
                y = 0;
                x++;
            }

            if (x < CUBE_DIMENSION) {
                setTimeout(addNextCube, 20); // Delay of 1 second
            }
        }
    }

    addNextCube(); // Start adding cubes
}
        const CUBE_DIMENSION = 3
        for (let x = 0; x < CUBE_DIMENSION; x++) {
            for (let y = 0; y < CUBE_DIMENSION; y++) {
                for (let z = CUBE_DIMENSION -1; z >= 0; z--) {
                    group.add(createCube(x, y, z));
                }
            }
        }

        highlightSlice();
        updateCubeGraphics();
        /*
        Creates a cube with initial coordinates and material objects for faces
        assigns cube to respective groups
        @param x, y, z position in Three.js scene
        */
        function createCube(x, y, z) {
            const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
            const colorMaterials = [
                new THREE.MeshBasicMaterial({ color: 0xFF0000 }), // Red - front
                new THREE.MeshBasicMaterial({ color: 0x0000FF }), // Blue - left
                new THREE.MeshBasicMaterial({ color: 0x00FF00 }), // Green - up
                new THREE.MeshBasicMaterial({ color: 0xFFFF00 }), // Yellow - down
                new THREE.MeshBasicMaterial({ color: 0xFFA500 }), // Orange - right
                new THREE.MeshBasicMaterial({ color: 0xFFFFFF })  // White - back
            ];
            const cube = new THREE.Mesh(geometry, colorMaterials);

            cube.userData = {
                coordinates: { x, y, z },
                faces: colorMaterials
            };
            cube.position.set(x-1, y-1, z-1);

            // Add cube to the appropriate groups by assigning orentation for coordinate faces
            /*
            Orientations:
            z+ Out of screen
            y+ up
            x+right
            */
            if (cube.userData.coordinates.z === 2) {groups["front"].push(cube); console.log("Added to front");}
            if (cube.userData.coordinates.z === 0){groups["back"].push(cube);console.log("Added to back");}
            if (cube.userData.coordinates.x === 0){ groups["left"].push(cube); console.log("Added to left");}
            if (cube.userData.coordinates.x === 2) {groups["right"].push(cube); console.log("Added to right");}
            if (cube.userData.coordinates.y === 0) {groups["down"].push(cube); console.log("Added to down");}
            if (cube.userData.coordinates.y === 2) {groups["up"].push(cube); console.log("added to up");}

            
            return cube;
        }
        /*
        Enum -> Object creator for interpereting int vals from face arrays
        Does NOT set a opacity, should be maintained from original material.
        */
        function numToColor(number) {

            const colorMaterials = [
                new THREE.MeshBasicMaterial({ color: 0xFF0000 }), // Red - front
                new THREE.MeshBasicMaterial({ color: 0x0000FF }), // Blue - left
                new THREE.MeshBasicMaterial({ color: 0x00FF00 }), // Green - up
                new THREE.MeshBasicMaterial({ color: 0xFFFF00 }), // Yellow - down
                new THREE.MeshBasicMaterial({ color: 0xFFA500 }), // Orange - right
                new THREE.MeshBasicMaterial({ color: 0xFFFFFF })  // White - back
            ];
            return colorMaterials[map[number]];
        }
        /*
        Highlights cubes at the given pointers indexes -> pointer[0] = 1: selects a "slice
        horizontally for rotation, horizontal triggered, selects in the perpindicular direction
        */
        function highlightSlice() {
            group.children.forEach(cube => {
                const coords = cube.userData.coordinates;
                let sliceIndex;

                if (pointer.horizontal) {
                    sliceIndex = pointer.x === 1 ? 2 - coords.y : 2 - coords.z;
                } else if (pointer.x === 0) {
                    sliceIndex = coords.x;
                } else if (pointer.x === 1) {
                    sliceIndex = 2 - coords.y;
                }
                cube.userData.faces.forEach(material => {
                    material.opacity = sliceIndex === pointer.y ? 1.0 : 0.4;
                    material.transparent = true;
                });
            });
        }
        /*
        Updates the scene and renders the graphics constantly
        */
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        /*
        Reads from .json file and updates the intended surfaces of cube
        Orientation is hardfixed on the index of each face within the material of each cubie
        (see comments below)
        @param cubeData the .json object containing the faces:
        front, back left right, up, down
        */
        async function updateCubeGraphics() {
    fetch('/fetch-data')
        .then(response => {
            if (!response.ok) {
                throw new Error('Data response was not ok! Status: ' + response.status);
            }
            return response.json();
        })
        .then(data => {
            console.log(data);
             let { frontFace, backFace, leftFace, rightFace, upFace, downFace } = data;
            if (!frontFace || !backFace || !leftFace || !rightFace || !upFace || !downFace) {
                console.error("One or more face data are undefined:", { front, back, left, right, up, down });
                return; // Stop further processing if data is incomplete
            }

            let processedBack = (backFace);
            let processedLeft = reflectArray(rotateArray(rotateArray(rotateArray(leftFace))));
            let processedRight = rotateArray(rightFace);
            let processedUp = rotateArray(rotateArray(reflectArray((upFace))));
            let processedDown =((downFace));
            let processedFront = reflectArray(rotateArray(rotateArray(frontFace)));
            updateFace(groups.front, processedFront, 4);
            updateFace(groups.back, processedBack, 5);
            updateFace(groups.left, processedLeft, 1);
            updateFace(groups.right, processedRight, 0);
            updateFace(groups.up, processedUp, 2);
            updateFace(groups.down, processedDown, 3);
        })
        .catch(error => {
            console.error("Error fetching or processing cube data:", error);
        });
}

        /*
        Updates the given group of cubies with the faceData
        @param group the group of cubies of the face
        @param faceData the int[][] array from .json file containing cube face data
        @param faceIndex the index designating the side; same face of cubie to update
        */
        function updateFace(group, faceData, faceIndex) {
            let i = 0, j = 0;
            
            group.forEach(cubie => {
                // Handle material update
                const oldMaterial = cubie.userData.faces[faceIndex];
                cubie.userData.faces[faceIndex] = numToColor(faceData[i][j]);
                cubie.userData.faces.forEach(face => {
                    face.opacity = oldMaterial.opacity;
                    face.transparent = oldMaterial.transparent;
                });

                if (i === 2) {
                    j = (j + 1) % 3;
                }
                i = (i + 1) % 3;
            });
        }

        
        /*
        * Fetches command from the springboot server at the given endpoint:
        * /send-command/${command}
        */
        function fetchCommand(command) {
                            fetch(`/send-command/${command}`, {
                                method: 'POST',
                                headers: {
                             'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({index: pointer.y})
                            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Data response was not ok!');
                    }
                    return response.json();
                });
                updateCubeGraphics();
        }
        //document.addEventListener('DOMContentLoaded', updateCubeGraphics);

        document.addEventListener('keydown', function (event) {
            switch (event.key) {
                case 'w':
                    if (pointer.horizontal) {
                        if (pointer.x === 0) {
                            fetchCommand('HU');
                        } else {
                            pointer.y = (pointer.y + 2) % 3;
                        }
                    } else {
                        if (pointer.x === 1) {
                            pointer.y = (pointer.y + 2) % 3;
                        } else {
                            fetchCommand('U');
                        }
                    }
                    break;

                case 's':
                    if (pointer.horizontal) {
                        if (pointer.x === 0) {
                            fetchCommand('HD');
                        } else {
                            pointer.y = (pointer.y + 1) % 3;
                        }
                    } else {
                        if (pointer.x === 1) {
                            pointer.y = (pointer.y + 1) % 3;
                        } else {
                            fetchCommand('D');
                        }
                    }
                    break;
                case 'a':
                    if (pointer.x === 0) {
                        pointer.y = (pointer.y - 1 + 3) % 3;

                    } else {
                        fetchCommand('L');
                    }
                    break;
                case 'd':
                    if (pointer.x === 0) {
                        pointer.y = (pointer.y + 1) % 3;
                    } else {
                        fetchCommand('R');
                    }
                    break;
                case ' ':
                    pointer.x = pointer.x === 1 ? 0 : 1;
                    break;
                case 'h':
                    pointer.horizontal = !pointer.horizontal;
                    break;
                case 'ArrowLeft':
                case 'ArrowRight':
                    const angle = event.key === 'ArrowLeft' ? Math.PI / 36 : -Math.PI / 36;
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                    break;
                case 'ArrowUp':
                case 'ArrowDown':
                    const tilt = event.key === 'ArrowUp' ? Math.PI / 36 : -Math.PI / 36;
                    camera.position.applyAxisAngle(new THREE.Vector3(1, 0, 0), tilt);
                    break;
            }
            camera.lookAt(scene.position);
            highlightSlice();
        });

        /*
        Array manipulation methods used to format .json data for ordered list of cubies
        since added order is determined by addition loop, we add each cubie to proper group
        and then update each cubie's face with data from .json file
        */

        /*
        Maps a given array as follows: (plane rotation)
        [1,2,3],[4,5,6],[7,8,9] - > [1,4,7][2,8,1][3,6,9]
        
        */
        function rotateArray(array) {
            if (array==null) {
                return;
            }
            const rows = array.length;
            const cols = array[0].length;
            let rotatedArray = [];

            for (let col = 0; col < cols; col++) {
                let newRow = [];
                for (let row = rows - 1; row >= 0; row--) {
                    newRow.push(array[row][col]);
                }
                rotatedArray.push(newRow);
            }

            return rotatedArray;
        }
       
        function reflectArray(array) {
            if (array==null) {return;}
            return array.map(row => row.slice().reverse());
        }

    </script>
</body>

</html>