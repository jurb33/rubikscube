<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Rubiks Cube</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; display: flex; flex-direction: column; align-items: center; }
        canvas { display: block; background-color: #EEE; }
    </style>
</head>
<body>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        camera.position.set(5, 5, 5);
        camera.lookAt(scene.position);
        

        const group = new THREE.Group(); //Collection of cubies
        const groups = {front: new Array(), right: new Array(), back: new Array(), left: new Array(), up: new Array(), down: new Array()};
        const pointer = { x: 0, y: 0, horizontal: false };  // pointer with horizontal selection
        scene.add(group);
        for (let x = 0; x < 3; x++) {
            for (let y = 2; y >= 0; y--) {
                for (let z = 2; z >= 0; z--) {
                    group.add(createCube(x, y, z));
                }
            }
        }
animate();


        function createCube(x, y, z) {
            const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
            const colorMaterials = [
                new THREE.MeshBasicMaterial({ color: 0xFF0000 }), // Red - front
               new THREE.MeshBasicMaterial({ color: 0x0000FF }), // Blue - left
                new THREE.MeshBasicMaterial({ color: 0x00FF00 }), // Green - up
                new THREE.MeshBasicMaterial({ color: 0xFFFF00 }), // Yellow - down
                new THREE.MeshBasicMaterial({ color: 0xFFA500 }), // Orange - right
                new THREE.MeshBasicMaterial({ color: 0xFFFFFF })  // White - back
        ];
            const cube = new THREE.Mesh(geometry, colorMaterials);
    
            cube.userData = { coordinates: { x, y, z }, 
            faces: colorMaterials
            };
            cube.position.set(x - 1, y - 1, z - 1);

            // Add cube to the appropriate groups
            if (cube.userData.coordinates.z === 2) groups["front"].push(cube);
            if (cube.userData.coordinates.z === 0) groups["back"].push(cube);
            if (cube.userData.coordinates.x === 0) groups["left"].push(cube);
            if (cube.userData.coordinates.x === 2) groups["right"].push(cube);
            if (cube.userData.coordinates.y === 0) groups["down"].push(cube);
            if (cube.userData.coordinates.y === 2) groups["up"].push(cube);

            
            return cube;
        }
        function numToColor(number) {
            const colorMaterials = [
                new THREE.MeshBasicMaterial({ color: 0xFF0000 }), // Red - front
               new THREE.MeshBasicMaterial({ color: 0x0000FF }), // Blue - left
                new THREE.MeshBasicMaterial({ color: 0x00FF00 }), // Green - up
                new THREE.MeshBasicMaterial({ color: 0xFFFF00 }), // Yellow - down
                new THREE.MeshBasicMaterial({ color: 0xFFA500 }), // Orange - right
                new THREE.MeshBasicMaterial({ color: 0xFFFFFF })  // White - back
        ];

    if (number < 1 || number > 6) {
        throw new Error("Invalid number. Please enter a number between 1 and 6.");
    }

    return colorMaterials[number - 1]; // Array index starts at 0, so subtract 1 from the number
}

        function highlightSlice() {
            group.children.forEach(cube => {
                const coords = cube.userData.coordinates;
                let sliceIndex;

                if (pointer.horizontal) {
                    sliceIndex = pointer.x === 1 ? 2 - coords.y : 2 - coords.z;
                } else if (pointer.x === 0) {
                    sliceIndex = coords.x;
                } else if (pointer.x === 1) {
                    sliceIndex = 2 - coords.y;
                }

                cube.material.forEach(material => {
                    material.opacity = sliceIndex === pointer.y ? 1.0 : 0.4;
                    material.transparent = true;
                });
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            highlightSlice();
            renderer.render(scene, camera);
            
        }
	async function fetchInitialState() {
    try {
        const response = await axios.get('http://localhost:8080/cube/state');
        updateCubeGraphics(response.data); // Function to update Three.js cube based on state
    } catch (error) {
        console.error('Failed to fetch initial cube state:', error);
    }
}

async function sendCommand(command) {
    try {
        const response = await axios.post('http://localhost:8080/cube/update', { command });
        updateCubeGraphics(response.data);
    } catch (error) {
        console.error('Error sending command:', error);
    }
}

async function updateCubeGraphics() {
    try {
        // Replace 'your-endpoint-url' with the actual URL of the Spring Boot server
        //const response = await fetch('http://localhost:8080/cube-state');
        //REMOVED for TESTING PURPOSES
       // if (!response.ok) {
        //    throw new Error('Network response was not ok');
       // }
        //const cubeData = await response.json();
        //Front requires reflection and rotation, based on the order of cube creation

        const front = cubeData.front;
        front = rotateArray(front);
        front = reflectArray(front);
        groups.front = front;

        const back = cubeData.back;
        back = rotateArray(back);
        back = reflectArray(back);
        groups.back = back;

        const left = cubeData.left;
        left = rotateArray(left);
        left = rotateArray(left);
        left = rotateArray(left);
        groups.left = left;

        const right = rotateArray(cubeData.right);
        right = reflectArray(right);
        groups.right = right;

        const up = rotateArray(cubeData.up);
        groups.up = up;
        let i, j = 0;
        groups.front.forEach(cubie =>{
            //0 is front index
            cubie.userData.faces[0] = groups["front"][i][j];
            if (i === 2) {
                j = (j + 1) % 3;
            }
            i = (i + 1) % 3;

            
        });
        groups.back.forEach(cubie =>{
            //0 is front index
            cubie.userData.faces[1] = groups["back"][i][j];
            if (i === 2) {
                j = (j + 1) % 3;
            }
            i = (i + 1) % 3;

            
        });
        groups.left.forEach(cubie =>{
            //0 is front index
            cubie.userData.faces[2] = groups["left"][i][j];
            if (i === 2) {
                j = (j + 1) % 3;
            }
            i = (i + 1) % 3;

            
        });
        groups.right.forEach(cubie =>{
            //0 is front index
            cubie.userData.faces[3] = groups["right"][i][j];
            if (i === 2) {
                j = (j + 1) % 3;
            }
            i = (i + 1) % 3;

            
        });
        groups.up.forEach(cubie =>{
            //0 is front index
            cubie.userData.faces[4] = groups["up"][i][j];
            if (i === 2) {
                j = (j + 1) % 3;
            }
            i = (i + 1) % 3;

            
        });

        groups.front.forEach(cubie =>{
            //0 is front index
            cubie.userData.faces[5] = groups["down"][i][j];
            if (i === 2) {
                j = (j + 1) % 3;
            }
            i = (i + 1) % 3;

            
        });

        
    } catch (error) {
        console.error('Failed to fetch cube data:', error);
    }
}

document.addEventListener('DOMContentLoaded', fetchInitialState);

        document.addEventListener('keydown', function(event) {
            switch (event.key) {
                case 'w':
		    if (pointer.horizontal) {
                        if (pointer.x === 0) {
                            //Up Command for horizontal
                        } else {
                            pointer.y = (pointer.y +2) %3;
                        }
                    } else {
			if (pointer.x === 1) {
                        pointer.y = (pointer.y + 2) % 3;
                    } else {
			//Up Command Here
		    }
        }
                    break;

                case 's':
                    if (pointer.horizontal) {
                        if (pointer.x === 0) {
                            //Down command for horizontal (cube.HD(pointer.y)
                        } else {
                            pointer.y = (pointer.y + 1) % 3;
                        }
                    } else {
			if (pointer.x === 1) {
                        pointer.y = (pointer.y + 1) %3;
                    } else {
			//Down Command Here (cube.D(pointer.y))
		}
    }
                    break;
                case 'a':
                    if (pointer.x === 0) {
                        pointer.y = (pointer.y -1 +3) %3;

                } else {
                    //LEFT command here (cube.L(pointer.y)
                }
                    break;
                case 'd':
                    if (pointer.x === 0) {
                        pointer.y = (pointer.y + 1) % 3;
                    } else {
                        //Right rotation, cube.R(pointer.y)
                    }
                    break;
                case ' ':
    
                    pointer.x = pointer.x === 1? 0 : 1;
                    break;
                case 'h':
                    pointer.horizontal = !pointer.horizontal;
                    break;
                case 'ArrowLeft':
                case 'ArrowRight':
                    const angle = event.key === 'ArrowLeft' ? Math.PI / 36 : -Math.PI / 36;
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                    break;
                case 'ArrowUp':
                case 'ArrowDown':
                    const tilt = event.key === 'ArrowUp' ? Math.PI / 36 : -Math.PI / 36;
                    camera.position.applyAxisAngle(new THREE.Vector3(1, 0, 0), tilt);
                    break;
            }
            camera.lookAt(scene.position);
            highlightSlice();
        });
        function rotateArray(array) {
    const rows = array.length;
    const cols = array[0].length;
    let rotatedArray = [];

    for (let col = 0; col < cols; col++) {
        let newRow = [];
        for (let row = rows - 1; row >= 0; row--) {
            newRow.push(array[row][col]);
        }
        rotatedArray.push(newRow);
    }

    return rotatedArray;
}
function reflectArray(array) {
    return array.map(row => row.slice().reverse());
}

    </script>
</body>
</html>